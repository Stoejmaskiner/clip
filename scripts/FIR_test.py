import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as dsp
import operator as op
from ring_buff import RingBuffer
from itertools import chain


LP_FIR_COEFFS_2X_TO_1X_MINIMUM = np.array(
    [
        0.005457910424612414,
        0.03454926847973096,
        0.11166819870771841,
        0.23430509097492636,
        0.339601871089326,
        0.32851284180983925,
        0.16104568324296611,
        -0.0670070864423072,
        -0.1815476590723997,
        -0.10080717498648997,
        0.06547080654397397,
        0.1283848972748332,
        0.0330923641923179,
        -0.08539038967047682,
        -0.07960013640841178,
        0.025949071654257985,
        0.08218031202442873,
        0.021983735516958577,
        -0.059116646214170544,
        -0.04874921624482684,
        0.02708137829823619,
        0.05507389068498668,
        0.0023415273636141825,
        -0.04653652422197656,
        -0.022912082291318667,
        0.030062222398327062,
        0.03277488948823678,
        -0.01186434537233211,
        -0.033107873928774144,
        -0.0035901796184068914,
        0.02676115651592609,
        0.013886852944915068,
        -0.017089069306934376,
        -0.01847455495214761,
        0.0070879187065264375,
        0.01817507278355491,
        0.0011145871475055687,
        -0.014579477767544426,
        -0.006436283927509998,
        0.009468897061481164,
        0.008743178994805702,
        -0.0043766406861268535,
        -0.008585686306639955,
        0.00032828563128620294,
        0.006855510938438694,
        0.0022145565363009536,
        -0.004487401812836481,
        -0.0032871784363819193,
        0.002217038336645772,
        0.003226052404495949,
        -0.0005055106355392048,
        -0.002521010600803382,
        -0.0005170925770042025,
        0.001587841783810125,
        0.0008920629274128404,
        -0.0007836339353099224,
        -0.000872596002113831,
        0.00019276991585828762,
        0.0005897889406980256,
        4.939874402642348e-05,
        -0.00036955790839175636,
        -0.00019625917383333806,
        9.369090764328244e-05,
        0.00012515229823208127,
    ]
)
LP_FIR_COEFFS_4X_TO_2X_MINIMUM = np.array(
    [
        0.003468469028194285,
        0.02239331158801039,
        0.07537848679353211,
        0.16920007489452382,
        0.2736260870241144,
        0.32139482407473335,
        0.2544224647191921,
        0.08651458550215266,
        -0.08489590876206546,
        -0.14982529243386739,
        -0.0826039541562885,
        0.03441067886874865,
        0.09092671415234242,
        0.05173557874137505,
        -0.023408722593767365,
        -0.05532446088301342,
        -0.02615062154220094,
        0.01828788503193158,
        0.030763097619783703,
        0.009967086162829958,
        -0.012439883723119386,
        -0.01443313271737807,
        -0.002229800961851232,
        0.006611497150556439,
        0.005279121194282256,
        -0.00011971423015298619,
        -0.002515867673900087,
        -0.0013472217651307595,
        0.0002470981102847266,
        0.0005690331614959307,
        0.00019856050188130086,
        -2.4921586921270042e-05,
    ]
)


class Upsample:
    def __init__(self):
        self.delay_line = RingBuffer(32)

    def step_even(self, x: float) -> float:
        a = 0.0
        for i in range(0, 32):
           ; a += self.delay_line[i] * LP_FIR_COEFFS_2X_TO_1X_MINIMUM[i * 2]
        return a

    def step_odd(self, x: float) -> float:
        a = 0.0
        for i in range(0, 32):
            a += self.delay_line[i] * LP_FIR_COEFFS_2X_TO_1X_MINIMUM[i * 2 + 1]
        return a

    def step(self, x: float) -> tuple[float, float]:
        self.delay_line.push(x)
        e = self.step_even(x)
        o = self.step_odd(x)
        return e * 2.0, o * 2.0


class Downsample:
    def __init__(self):
        self.delay_line = RingBuffer(64)

    def step(self, x: tuple[float, float]) -> float:
        self.delay_line.push(x[0])
        self.delay_line.push(x[1])
        a = 0.0
        for i in range(0, 64):
            a += self.delay_line[i] * LP_FIR_COEFFS_2X_TO_1X_MINIMUM[i]
        return a


noise = np.random.random(10000)

us = Upsample()
ds = Downsample()
us_pairs = [us.step(n) for n in noise]
noise_us = np.array(list(chain(*us_pairs)))
noise_ds = np.array([ds.step(p) for p in us_pairs])

f, s = dsp.welch(noise)
fus, sus = dsp.welch(noise_us)
fds, sds = dsp.welch(noise_ds)

plt.plot(f, s)
plt.plot(fus * 2, sus)
plt.plot(fds, sds)
plt.show()

print(sum(noise) / len(noise))
print(sum(noise_us) / len(noise_us))
print(sum(noise_ds) / len(noise_ds))
